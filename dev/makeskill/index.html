<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>New skill tutorial · ADoSnipsQnD</title><link rel="canonical" href="https://andreasdominik.github.io/ADoSnipsQnD/dev/makeskill/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="ADoSnipsQnD logo"/></a><h1>ADoSnipsQnD</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../snipsHermesQnD/">SnipsHermesQnD</a></li><li class="current"><a class="toctext" href>New skill tutorial</a><ul class="internal"><li><a class="toctext" href="#Set-up-the-framework-(if-starting-from-scratch)-1">Set up the framework (if starting from scratch)</a></li><li><a class="toctext" href="#Set-up-the-skeleton-a-new-project-1">Set up the skeleton a new project</a></li><li><a class="toctext" href="#Files-in-the-sceleton-1">Files in the sceleton</a></li><li><a class="toctext" href="#Example-with-low-level-API-1">Example with low-level API</a></li></ul></li><li><a class="toctext" href="../api/api/">API Documentation</a></li><li><a class="toctext" href="../LICENSE/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>New skill tutorial</a></li></ul><a class="edit-page" href="https://github.com/andreasdominik/ADoSnipsQnD/blob/master/docs/src/makeskill.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>New skill tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="How-to-write-a-new-skill-1" href="#How-to-write-a-new-skill-1">How to write a new skill</a></h1><p>Starting with a new skill can be done by adapting the template skill to your needs. However, several files need to be modified. Therefore a shell script is provided, which takes care of the major part of the modifications.</p><p>This brief tutorials guides through the process of making a new skill using the init script and template in Julia language.</p><h2><a class="nav-anchor" id="Set-up-the-framework-(if-starting-from-scratch)-1" href="#Set-up-the-framework-(if-starting-from-scratch)-1">Set up the framework (if starting from scratch)</a></h2><p>Create a directory in which the skills will be developed, such as <code>~/Documents/Snips/</code> and make a clone of the framework project at GitHub (install the git software before, if necessary):</p><pre><code class="language-bash">$ ~/Documents/Snips/
$ cd  ~/Documents/Snips/
$ git clone git@github.com:andreasdominik/ADoSnipsQnD.git</code></pre><p>Now you have the source code of the framework in a local clone in the directory <code>~/Documents/Snips/ADoSnipsQnD/</code>.</p><h2><a class="nav-anchor" id="Set-up-the-skeleton-a-new-project-1" href="#Set-up-the-skeleton-a-new-project-1">Set up the skeleton a new project</a></h2><p>Before strating, prepare to give the init-script some information:</p><ul><li><em>name of the new skill:</em> the name must not contain any whitespace,     must be unique within your Snips skills,     and must be unique within your GitHub repositories.     The example below will create a skill to control an Amazon Fire device.     Therefore in this tutorial the name <code>MyFire</code> will be used as example.</li><li><em>your GitHub name:</em> create a GitHub account in necessary.</li><li><em>your gitHub password:</em> name and password are needed, because the script will     initialise a new GitHub repo for the new project.</li></ul><p>The script <code>init.sh</code> in the directory <code>/bin</code> will create a skeleton of the new skill. Enter (or stay in) the directory <code>~/Documents/Snips/</code> and run the script:</p><pre><code class="language-bash">$ cd ~/Documents/Snips
$ ./ADoSnipsQnD/bin/init.sh</code></pre><p>Now provide the prepered information and follow the instructions of the script. At the end, the skeleton of a skill is created, committed into the git repo and pushed to GitHub.</p><p>All file- and directory names can be left unchanged. The skill has no file <code>action-...</code> as demanded by the Snips skill server, because all SnipsHermesQnD-skills will run in the same Julia process. Only the framework it self has the starter function <code>action-ADoSnipsQnD.jl</code>, all other skill have a loader function <code>loader-...</code> instead, which is recognised by the framework and loaded into the running instance.</p><h2><a class="nav-anchor" id="Files-in-the-sceleton-1" href="#Files-in-the-sceleton-1">Files in the sceleton</a></h2><p>The created skeleton consists of several files, but only some of them need to be adapted for a new skill.</p><table><tr><th style="text-align: right">filename</th><th style="text-align: right">comment</th><th style="text-align: right">needs to be adapted</th></tr><tr><td style="text-align: right"><code>loader-MyFire.jl</code></td><td style="text-align: right">generated loader function for the framework</td><td style="text-align: right">no</td></tr><tr><td style="text-align: right"><code>config.ini</code></td><td style="text-align: right">ini file as default in Snips</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>setup.sh</code></td><td style="text-align: right">setup file as default in Snips</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>api.jl</code></td><td style="text-align: right">source code of Julia low-level API for a controlled device</td><td style="text-align: right">optional</td></tr><tr><td style="text-align: right"><code>config.jl</code></td><td style="text-align: right">global initialisation of a skill</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>exported.jl</code></td><td style="text-align: right">geberated exported function of the skill module</td><td style="text-align: right">no</td></tr><tr><td style="text-align: right"><code>languages.jl</code></td><td style="text-align: right">text fragments for multi-language support</td><td style="text-align: right">optional</td></tr><tr><td style="text-align: right"><code>skill-actions.jl</code></td><td style="text-align: right">functions to be executed, if an intent is recognised</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>MyFire.jl</code></td><td style="text-align: right">the julia module for the skill</td><td style="text-align: right">no</td></tr></table><p>In a minimum-setup only 2 things need to be adapted for a new skill:</p><ul><li>the action-functions which respond to an intent (the <em>direct</em> action, no callback) must be definded and implemented (<code>skill-actions.jl</code>)</li><li>the action-functions must be connected with the corresponding intent names (<code>config.jl</code>).</li></ul><p>Optionally, more fine-grained software engineering is possible by</p><ul><li>separating the user-interaction from the API of controlled devices (latter will go to <code>api.jl</code>).</li><li>adding multi-language support, by specifying phrases in different languages (<code>languages.jl</code>) and by using different intents, depending on the language defined in <code>config.ini</code>.</li><li>the <code>setup.sh</code> file has the same function as in every Snips skill: setup the environement for the skill and install dependencies. In case of the QnD framework main purpose of <code>setup.sh</code> is to install Julia packages, necessray for a skill. The framework only installs the packages <code>JSON</code> and <code>StatsBase</code>. Additional packages can be installed by uncommenting the respective line in the file and adding the required dependency.</li></ul><h2><a class="nav-anchor" id="Example-with-low-level-API-1" href="#Example-with-low-level-API-1">Example with low-level API</a></h2><p>This tutorial shows how a skill to control an external device can be derived from the template.</p><p>The idea is to control an Amazon fire stick with a minimum set of commands <code>on, off, play, pause</code>. More commands can be implement easily the same way.</p><p>Switching on and off is implemented based on the common on-off-intent, included in the framework.</p><h3><a class="nav-anchor" id="The-Amazon-fire-low-level-API-1" href="#The-Amazon-fire-low-level-API-1">The Amazon fire low-level API</a></h3><p>The low-level API which sends commands to the Amazon fire is borrowed from Matt&#39;s ADBee project (<code>git@github.com:mattgyver83/adbee.git</code>) that provides a shell-script to send commands to the Amazon device. Please read theer for the steps to prepare the Amazon device for the remote control via ADB.</p><p>Although Python programmes usually find Python packages for every task, it is a very good idea to implement the lowest level af any device-control API as a shell script. Advantages:</p><ul><li>easy to write</li><li>fast and without any overhead</li><li>easy to test: the API canbe tested by just running the script from commandline as <code>controlFire ON</code> or <code>controlFire OFF</code> and see what happens.</li></ul><p>The simplified ADBee-script is:</p><pre><code class="language-sh">#!/bin/bash -xv
# control fireTv via adb

COMMANDS=$@
IP=amazon-fire  # set to 192.168.1.200 by dhcp
PORT=5555
ADB=adb
SEND_KEY=&quot;$ADB -s $IP:$PORT shell input keyevent&quot;

adb connect amazon-fire

for CMD in $COMMANDS ; do
  case $CMD in
    wake)
      $SEND_KEY KEYCODE_WAKEUP
      ;;
    sleep)
      $SEND_KEY KEYCODE_POWER
      ;;
    play)
      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE
      ;;
    pause)
      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE
      ;;
    # more commands may go here ...
  esac
done</code></pre><p>Once this script is tested, the Julia API can be set up.</p><h3><a class="nav-anchor" id="The-Julia-API-1" href="#The-Julia-API-1">The Julia API</a></h3><p>By default the API goes into the file api.jl, which is empty in the template.</p><p>In this case only a wrapper is needed, to make the API-commands available in the Julia program. The framework provide a function <code>tryrun()</code> to execute external commands safely (i.e. if an error occures, the program will not crash, but reading the error message via Hermes text to speech).</p><p>This API definition splits in the function to execute the ADBee-script and functions to be called by the user:</p><pre><code class="language-Julia">function adbCmds(cmds)

    return tryrun(`$ADB $(split(cmds))`, errorMsg =
            &quot;&quot;&quot;An error occured while sending commands $cmds
            to Amazon fire.&quot;&quot;&quot;
end




function amazonON()
    adbCmds(&quot;wake&quot;)
end

function amazonOFF()
    adbCmds(&quot;sleep&quot;)
end

function amazonPlay()
    adbCmds(&quot;play&quot;)
end

function amazonPause()
    adbCmds(&quot;pause&quot;)
end</code></pre><h3><a class="nav-anchor" id="The-skill-action-for-on/off-1" href="#The-skill-action-for-on/off-1">The skill-action for on/off</a></h3><p>This functions are executed by the framework if an intent is recognised. The functions are defined in the file <code>skill-actions.jl</code>. On/off is handled via the common on/off-intent, all other actions need a specific intent, that must be set up in the Snips console.</p><pre><code class="language-Julia">&quot;&quot;&quot;
function powerOnOff(topic, payload)

    Power on or of with SnipsHermesQnD mechanism.
&quot;&quot;&quot;
function powerOnOff(topic, payload)

    if isOnOffMatched(payload, DEVICE_NAME) == :on
        Snips.publishEndSession(&quot;I wake up the Amazon Fire Stick.&quot;)
        amazonON()
        return true

    elseif isOnOffMatched(payload, DEVICE_NAME) == :off
        Snips.publishEndSession(&quot;I send the Amazon Fire Stick to sleep.&quot;)
        amazonOFF()
        return true

    else
        return false
    end
end</code></pre><p>Returning <code>false</code> will disable the <em>continue without hotword</em> function; i.e. a hotword is necessary before the next command can be uttered. This is necessary for the default-case, because probably a different app will execute this non-recognised command.</p><p>In order to ensure that the framework accepts on-off-commands for the new device, it must be added to the list of handled devices in the <code>config.ini</code> of the framework. The Amazon Fire Stick is already defined as device-type in the slot <code>device</code> of the intent.</p><pre><code class="language-none">on_off_devices=floor_light,light,amazon_fire</code></pre><h3><a class="nav-anchor" id="The-skill-action-for-all-other-commands-1" href="#The-skill-action-for-all-other-commands-1">The skill-action for all other commands</a></h3><p>All other commands must be handled by an intent that you must create in the Snips console. Let&#39;s assume the intent has the name <code>MyFire</code> and delivers the command in the slot <code>Command</code>. The slot should know all known commands with synonyms.</p><p>To handle this, a second skill-action has to be defined in the file <code>skill-actions.jl</code>:</p><pre><code class="language-Julia">&quot;&quot;&quot;
function commands(topic, payload)

    Send commands to Amamzon device.
&quot;&quot;&quot;
function commands(topic, payload)

    if Snips.isInSlot(payload, SLOT_NAME, &quot;play&quot;)
        Snips.publishEndSession(&quot;I play the current selection!&quot;)
        amazonPlay()
        return true

    elseif Snips.isInSlot(payload, SLOT_NAME, &quot;pause&quot;)
        Snips.publishEndSession(&quot;I pause the movie.&quot;)
        amazonPause()
        return true

    else
        Snips.publishEndSession(&quot;I cannot respond!&quot;)
        return true
    end
end</code></pre><h3><a class="nav-anchor" id="Tying-everything-together-1" href="#Tying-everything-together-1">Tying everything together</a></h3><p>The last step is to tell the skill the names of intents to listen and the names of the slots to extract values from. Both is defined in the file <code>config.jl</code>:</p><ul><li>The slot names are simply defined as global constants (they are global within the module MyFire).</li><li>Intents and respective functions are stored in the background and registered with the function <code>registerIntentAction()</code>.</li></ul><pre><code class="language-Julia">const SLOT_NAME = &quot;Command&quot;

...

Snips.registerIntentAction(&quot;AdoSnipsOnOffEN&quot;, powerOnOff)
Snips.registerIntentAction(&quot;MyFire&quot;, commands)</code></pre><p>Once the functuions are registered together with the intents, the framework will execute the functions.</p><footer><hr/><a class="previous" href="../snipsHermesQnD/"><span class="direction">Previous</span><span class="title">SnipsHermesQnD</span></a><a class="next" href="../api/api/"><span class="direction">Next</span><span class="title">API Documentation</span></a></footer></article></body></html>
