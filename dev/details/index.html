<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Some Details · ADoSnipsQnD</title><link rel="canonical" href="https://andreasdominik.github.io/ADoSnipsQnD/dev/details/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.svg" alt="ADoSnipsQnD logo"/></a><h1>ADoSnipsQnD</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../snipsHermesQnD/">SnipsHermesQnD</a></li><li><a class="toctext" href="../makeskill/">New skill tutorial</a></li><li class="current"><a class="toctext" href>Some Details</a><ul class="internal"><li><a class="toctext" href="#Strategy-1">Strategy</a></li><li><a class="toctext" href="#Common-intent-for-on/off-1">Common intent for on/off</a></li><li><a class="toctext" href="#Reduce-false-activations-of-intents-1">Reduce false activations of intents</a></li><li><a class="toctext" href="#Ask-and-answer-Yes-or-No-1">Ask and answer Yes-or-No</a></li><li><a class="toctext" href="#Continue-conversation-without-hotword-1">Continue conversation without hotword</a></li><li><a class="toctext" href="#Multi-language-support-1">Multi-language support</a></li><li><a class="toctext" href="#System-triggers-1">System triggers</a></li><li><a class="toctext" href="#Managing-the-Julia-footprint-1">Managing the Julia footprint</a></li></ul></li><li><a class="toctext" href="../api/api/">API Documentation</a></li><li><a class="toctext" href="../LICENSE/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Some Details</a></li></ul><a class="edit-page" href="https://github.com/andreasdominik/ADoSnipsQnD/blob/master/docs/src/details.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Some Details</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Some-details-1" href="#Some-details-1">Some details</a></h1><h2><a class="nav-anchor" id="Strategy-1" href="#Strategy-1">Strategy</a></h2><p>The idea behind the framework is, to put as much as possible in the background so that a developer only needs to provide the code for the functions executed for an intent.</p><p>The MQTT-messages of <em>Hermes</em> and the <em>Dialogue Manager</em> are wrapped, and additional interfaces to <em>Hermes</em> are provided to enable direct dialogues without using callbacks.</p><p>In addion background information, such as current session-ID or current site-ID, are handled in the background and not exposed to a skill developer.</p><p>Additional utilities are provided to</p><ul><li>read values from intent slots,</li><li>read values from <code>config.ini</code>,</li><li>write apps for more then one language,</li><li>get an answer form the NLU back as function value in the control flow of a function,</li><li>use a global intent for switching a device on or off,</li><li>let Snips ask a question and get &quot;yes&quot; or &quot;no&quot; back as boolean value,</li><li>let Snips continue a conversation without the need to utter the, hotword again,</li><li>execute actions of other skills by submitting system triggers.</li></ul><h2><a class="nav-anchor" id="Common-intent-for-on/off-1" href="#Common-intent-for-on/off-1">Common intent for on/off</a></h2><p>The on/off-intent, integrated with the SnipsHermesQnD framework, allows for writing apps to power up or down devices, without the need to create a new intent for every device.</p><p>Background: All home assistants run into problems when many intents are responsible to switch on or off a device. Obviously all these intends are very similar and reliable detection of the correct intent is not easy.</p><p>SnipsHermesQnD tries to work around this issue, by using only one intent for all on/off-commands.</p><p>All supported devices are listed in the slot <code>device</code> of the intent <code>ADoSnipsOnOff&lt;EN/DE&gt;</code> and defined in the slot type <code>device_Type</code>.</p><p>The app <code>ADoSnipsHermesQnD</code> has some code behind to handle unrecognised devises. The associated <code>config.ini</code> defines the list of devices handled by skills in your assistant. Any device that is not in this list, will be ignored; i.e. the framework will end the respective ADoSnipsOnOff-session without any action immediately.</p><p>If you want to use the intent to swich an additional device on or off</p><ul><li>firstly look in the intent <code>ADoSnipsOnOff&lt;EN/DE&gt;</code> if the device is already defined in the slot type <code>device_Type</code>. If not, you will have to create a fork of the intent and add a new device to the values of the slot type <code>device_Type</code>.</li><li>secondly the new device must be added to the list of devices in the <code>config.ini</code> of the framework (<code>ADoSnipsHermesQnD_&lt;EN/DE&gt;</code>). Add the name to the comma-separated list of devices in the parameter <code>on_off_devices</code>.</li></ul><p>The framework comes with a function <code>isOnOffMatched(payload, DEVICE_NAME)</code> which can be called with the current payload and the name (and optionally with the siteId) of the device of interest. It will return one of</p><ul><li><code>:on</code>, if an &quot;ON&quot; is recognised for the device</li><li><code>:off</code>, if an &quot;OFF&quot; is recognised for the device</li><li><code>:matched</code>, if the device is recognised but no specific on or off</li><li><code>:unmatched</code>, if the device is not recognised.</li></ul><p>The tutorial shows a simple example how to use this functionality.</p><h2><a class="nav-anchor" id="Reduce-false-activations-of-intents-1" href="#Reduce-false-activations-of-intents-1">Reduce false activations of intents</a></h2><p>Intents with simple commands or without slots are sometimes recognised by Snips with high confidence, even if only parts of the command matches. This is because Snips tries to find the best matching intent for every uttered command.</p><p>The QnD-framework provides a mechanism to cancel intents, recognised by the NLU, by double-checking against ordered lists of words that must be present in a command to be valid.</p><p>This is configured in the <code>config.ini</code> with parameters of the form:</p><ul><li><code>&lt;intentname&gt;:must_include:&lt;description&gt;=&lt;list of words&gt;</code></li></ul><p>An example would be:</p><ul><li><code>switchOnOff:must_include:1=on,light</code></li><li><code>switchOnOff:must_include:rev=light,on</code></li></ul><p>Several lines of colon-separated parts are possible:</p><ul><li>the first part is the intent name (because a <code>config.ini</code> is responsible for several intents)</li><li>the second part must be exactly the phrase <code>must_include</code></li><li>the last part of the parameter name can be used as a description and is necessary to make all parameter lines unique</li><li>the parameter value is a comma-separated list of words.</li></ul><p>Each uttered command must include all words in the correct order of at least one parameter lines.</p><p>the framework performs this doublecheck before an action is started. If the check fails the session is ended silently.</p><h2><a class="nav-anchor" id="Ask-and-answer-Yes-or-No-1" href="#Ask-and-answer-Yes-or-No-1">Ask and answer Yes-or-No</a></h2><p>An often needed functionality is a quick confirmation feedback of the user. This is provided by the framework function <code>askYesOrNo(question)</code>.</p><p>See the following self-exlpaining code as example:</p><pre><code class="language-Julia">&quot;&quot;&quot;
    destroyAction(topic, payload)

Initialise self-destruction.
&quot;&quot;&quot;
function destroyAction(topic, payload)

  # log message:
  println(&quot;[ADoSnipsDestroyYourself]: action destroyAction() started.&quot;)

  if Snips.askYesOrNo(&quot;Do you really want to initiate self-destruction?&quot;)
    Snips.publishEndSession(&quot;Self-destruction sequence started!&quot;)
    boom()
  else
    Snips.publishEndSession(&quot;&quot;&quot;OK.
                            Self-destruction sequence is aborted!
                            Live long and in peace.&quot;&quot;&quot;)
  end

  return true
end</code></pre><p>The intent to capture the user response comes with the framework and is activated just for this dialogue.</p><h2><a class="nav-anchor" id="Continue-conversation-without-hotword-1" href="#Continue-conversation-without-hotword-1">Continue conversation without hotword</a></h2><p>Sometimes it is necessary to control a device with a sequence of several comands. In this case it is not natural to speak the hotword everytime. like:</p><blockquote><p><em>hey Snips</em></p><p><em>switch on the light</em></p><p><em>hey Snips</em></p><p><em>dim the light</em></p><p><em>hey Snips</em></p><p><em>dim the light again</em></p><p><em>hey Snips</em></p><p><em>dim the light again</em>    </p></blockquote><p>Instead, we want something like:</p><blockquote><p><em>hey Snips</em></p><p><em>switch on the light</em></p><p><em>dim the light</em></p><p><em>dim the light again</em></p><p><em>dim the light again</em>    </p></blockquote><p>This can be achieved by starting a new session just after an intent is processed. In the SnipsHermesQnD framework this is controlled by two mechanisms:</p><p>The <code>config.jl</code> defines a constant <code>const CONTINUE_WO_HOTWORD = true</code>. <code>true</code> is the default and hence continuation without hotword is enabled by default. To completely disable it for your skill, just set the constant to <code>false</code>.     The second mechanism is the return value of every single skill-action. A new session will only be started if both are true, the constant <code>CONTINUE_WO_HOTWORD</code> and the return value of the function. This way it is possible to decide for each action individually, if a hotword is required for the next command.</p><h2><a class="nav-anchor" id="Multi-language-support-1" href="#Multi-language-support-1">Multi-language support</a></h2><p>Multi-language skills need to be able to switch between laguages. In the context of Snips this requires special handling in two cases:</p><ul><li>All text, uttered by the assistant must be defined in all languages.</li><li>An intent is always tied to one language. Therefore for multi-language skills similar intents (with the same slots) must be created for each supported language.</li></ul><p>Multi-language support ist added in 4 steps:</p><h3><a class="nav-anchor" id=")-Define-language-in-config.ini:-1" href="#)-Define-language-in-config.ini:-1">1) Define language in config.ini:</a></h3><p>The <code>config.ini</code> must have a line like:</p><pre><code class="language-Julia">language=en</code></pre><h3><a class="nav-anchor" id=")-Define-the-texts-in-all-languages:-1" href="#)-Define-the-texts-in-all-languages:-1">2) Define the texts in all languages:</a></h3><p>To let Snips speak different languages, all texts must be added to a dictionary for all target languages. These are defined in the file <code>languages.jl</code> with help of the helper-function <code>addText()</code>. <code>addText()</code> needds the language (as String) and a key (as Symbol) to identify each text sniplet in each language. Texts can be Strings or lists of Strings, as shown in the Template:</p><pre><code class="language-Julia">Snips.addText(&quot;de&quot;, :iam, &quot;Ich bin dein Assistent&quot;)
Snips.addText(&quot;de&quot;, :isay, [&quot;Ich soll sagen&quot;, &quot;Ich sage&quot;, &quot;Das Wort ist&quot;])
Snips.addText(&quot;de&quot;, :bravo, &quot;Bravo, du hast erfolgreich das Template installiert!&quot;)
...
Snips.addText(&quot;en&quot;, :iam, &quot;I am your home assistant&quot;)
Snips.addText(&quot;en&quot;, :isay, [&quot;You told me to say&quot;, &quot;I say&quot;])
Snips.addText(&quot;en&quot;, :bravo, &quot;Bravo, you managed to install the template!&quot;)
Snips.addText(&quot;en&quot;, :bravo, &quot;The template app is running!&quot;)
...</code></pre><h3><a class="nav-anchor" id=")-Create-similar-intents-for-all-languages:-1" href="#)-Create-similar-intents-for-all-languages:-1">3) Create similar intents for all languages:</a></h3><p>The most time-consuming step ist to create the intents in the Snips console - however this is necessary, because speach-to-text as well as natural language understanding highly depend on the language.</p><h3><a class="nav-anchor" id=")-Switch-between-languages:-1" href="#)-Switch-between-languages:-1">4) Switch between languages:</a></h3><p>The <code>config.jl</code> of the template app shows how switching languages is possible within SnipsHermesQnD:</p><pre><code class="language-Julia">const LANG = Snips.getIniLanguage() != nothing ? Snips.getIniLanguage() : &quot;en&quot;

...

if LANG == &quot;de&quot;
    Snips.registerIntentAction(&quot;myNewIntentDE&quot;, myNewSkillfun)
    Snips.registerIntentAction(&quot;myNextIntentDE&quot;, myNextSkillfun)
elseif LANG == &quot;en&quot;
    Snips.registerIntentAction(&quot;myNewIntentEN&quot;, myNewSkillfun)
    Snips.registerIntentAction(&quot;myNextIntentEN&quot;, myNextSkillfun)
    TEXTS = TEXTS_EN
else
    Snips.registerIntentAction(&quot;myNewIntentEN&quot;, myNewSkillfun)
    Snips.registerIntentAction(&quot;myNextIntentEN&quot;, myNextSkillfun)
    TEXTS = TEXTS_EN
end</code></pre><p>The first line tries to read the language from <code>config.ini</code> and sets it to the default if no definition is found. The latter part selects the intents to be used.</p><h3><a class="nav-anchor" id=")-Utter-texts-in-the-defined-language:-1" href="#)-Utter-texts-in-the-defined-language:-1">5) Utter texts in the defined language:</a></h3><p>In the code, the text sniplets can be accessed with the <code>langText()</code>-function, such as:</p><pre><code class="language-Julia">Snips.publishEndSession(Snips.langText(:bravo))</code></pre><p>All framework function also support the shortcut and will expand the text fromkey and language:</p><pre><code class="language-Julia">Snips.publishEndSession(:bravo)</code></pre><p>The framework will deliver the text sniplet in the language specified in <code>config.ini</code> (or in the default language instead).</p><h2><a class="nav-anchor" id="System-triggers-1" href="#System-triggers-1">System triggers</a></h2><p>Triggers extend the concept of sending MQTT-messages between Snips components to communication between apps or the system or timers and apps. A trigger is a MQTT with a topic like</p><pre><code class="language-none">qnd/trigger/andreasdominik:ADoSnipsLights</code></pre><p>and a payload in JSON format:</p><pre><code class="language-none">    {
      &quot;target&quot; : &quot;qnd/trigger/andreasdominik:ADoSnipsLights&quot;,
      &quot;origin&quot; : &quot;ADoSnipsScheduler&quot;,
      &quot;time&quot; : timeString,
      &quot;trigger&quot; : {
        &quot;room&quot; : &quot;default&quot;,
        &quot;device&quot; : &quot;floor_lamp&quot;,
        &quot;onOrOff&quot; : &quot;ON&quot;,
        &quot;settings&quot; : &quot;undefined&quot;
      }
    }</code></pre><p>Skills can subscribe to triggers as to normal Snips intents with the function <code>registerTriggerAction()</code> as well as publish triggers with <code>publishTriggerAction()</code>. This way it is possible to</p><ul><li>execute actions in other skills (by publishing the respective trigger)</li><li>execute action with a time (by letting publish the trigger by the linux <code>at</code> command).</li></ul><h2><a class="nav-anchor" id="Managing-the-Julia-footprint-1" href="#Managing-the-Julia-footprint-1">Managing the Julia footprint</a></h2><p>The language Julia has a much bigger footprint as Python, consuming between 50-200 MB per Julia instance. In consequence it is not possible to run many Julia skills as separate processes, like it is possible with Python programs.</p><p>To work around this issue, all skills within this framework are running in the same Julia progress. This reduces the footprint as well as the compile times (because the libraries must be compiled only once).</p><p>It is still possible to add skills in the Snips console like all other skills. The only difference is, that the <code>action-...</code> executable of a skill is replaced by a <code>loader-...</code> script, which is recognised by the framework and loaded.</p><footer><hr/><a class="previous" href="../makeskill/"><span class="direction">Previous</span><span class="title">New skill tutorial</span></a><a class="next" href="../api/api/"><span class="direction">Next</span><span class="title">API Documentation</span></a></footer></article></body></html>
