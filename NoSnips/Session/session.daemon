#!/bin/bash -vx
#
# Session manager for NoSnips replacement service.
# Usage:
#     session.daemon path/to/nosnips.toml
#
# https://github.com/dbohdan/remarshal is used for reading toml
# jq is used for parsing JSON
#

# set config file:
#
if [[ $# -lt 1 ]] ; then
  CONFIG="/etc/nosnips.toml"
else
  CONFIG=$1
fi

# load tool funs:
#
THIS_DIR=$(dirname $(readlink -f $0))
BASE_DIR="$(dirname $THIS_DIR)"

source $BASE_DIR/Tools/funs.sh
source $BASE_DIR/Session/actionfuns.sh

# parse config from toml:
# PUBLISH, SUBSCRIBE, MQTT_PORT, MQTT_HOST,
# BASE_DIR, WORK_DIR, SITE_ID
#
readToml $CONFIG

TIMEOUT="$(extractJSON .hotword.session_timeout)"

# execute scripts for actions:
#
RUN_ACTION_SCRIPT=$BASE_DIR/Session/runaction.sh
RUN_NOTIFICATION_SCRIPT=$BASE_DIR/Session/runnotification.sh

# Topics to listen to:
#
TOPIC_HOTWORD="hermes/hotword/default/detected"
TOPIC_API="hermes/dialogueManager/startSession"

TOPIC_END="hermes/dialogueManager/endSession"
TOPIC_CONTINUE="hermes/dialogueManager/continueSession"
TOPIC_TIMEOUT="nosnips/timeout"

TOPIC=TOPIC_HOTWORD_ON="hermes/hotword/toggleOn"

# core loop that catches all MQTTs depending on
# state:
#
NEXT_SUBSRCIBE="start_session"
while true ; do

  case "$NEXT_SUBSRCIBE" in
    start_session)
      subscribeStartSession
      ;;
  esac


  # wait for a session start MQTT
  # defines: MQTT_TOPIC, MQTT_PAYLOAD and MQTT_SITE_ID
  #
  subscribeOnce $TOPIC_HOTWORD $TOPIC_API
  SESSION_SITE_ID=$MQTT_SITE_ID

  # if hotword or start session, start a new session:
  #
  DO="ignore"
  if [[ $MQTT_TOPIC == $TOPIC_HOTWORD ]] ; then
    DO="action"
    TRIGGERED_BY="hotword detected"

  elif [[ $MQTT_TOPIC == $TOPIC_API ]] ; then
    TRIGGERED_BY="start session API call"
    TYPE="$(extractJSON .init.type $MQTT_PAYLOAD)"

    if [[ $TYPE == "action" ]] ; then
      DO="action"
    else
      DO="notification"
    fi
  fi

  # now a new session is started!
  #
  if [[ $DO != ignore ]] ; then
    SESSION_ID="$(uuidgen)"

    # construct MQTT message for session started
    #
    TOPIC="hermes/dialogueManager/sessionStarted"
    PAYLOAD="{
      \"sessionId\": \"$SESSION_ID\",
      \"siteId\": \"$SESSION_SITE_ID\",
      \"customData\": \"Session started because of $TRIGGERED_BY\"
    }"
    $PUBLISH -t $TOPIC -m $PAYLOAD

    # prepare timeout:
    # (i.e. create a new timeout-id and schedule mqtt trigger)
    #
    scheduleTimeOut $TIMEOUT $SESION_SITE_ID

    # run the session until session end message:
    #
    if [[ $DO == "action" ]] ; then
      runactionfun &
      ACTION_PID=$!
    elif [[ $DO == "notifiation" ]] ; then
      runnotificationfun &
      ACTION_PID=$!
    fi

    # wait for session timeout:
    #
    DO_SESSION="run"
    while [[ $DO_SESSION == "run" ]] ; do

      subscribeSiteOnce $SESION_SITE_ID $TOPIC_END $TOPIC_CONTINUE $TOPIC_TIMEOUT

      if [[ $MQTT_TOPIC == $TOPIC_CONTINUE ]] ; then
        scheduleTimeOut $TIMEOUT $SESION_SITE_ID
        $RUN_ACTION $MQTT_PAYLOAD &

      elif [[ $MQTT_TOPIC == $TOPIC_END ]] ; then
        DO_SESSION="end"

      elif [[ $MQTT_TOPIC == $TOPIC_TIMEOUT ]] &&
           [[ $TIMEOUT_ID == $(extractJSON .timeoutID $MQTT_PAYLOAD)]] ; then
        DO_SESSION="timeout"
        kill -9 $ACTION_PID
      fi
    done
  fi # do != ignore
  #
  # end action
done
